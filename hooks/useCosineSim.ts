/**
 * Represents an entry from your database that includes an embedding.
 * Adjust the `id` and other properties like `text` to match your actual database schema.
 * The `embedding` field is crucial. If you store it as a JSON string in SQLite,
 * you'll need to parse it into a number[] before using it with these functions.
 */
export interface DatabaseEntry {
  id: number | string; // Or whatever type your ID is
  text?: string; // Optional: other data you want to associate
  embedding: number[] | string; // Embedding vector or JSON string of the vector
}

/**
 * Represents the result of a similarity comparison.
 */
export interface SimilarityResult {
  id: number | string;
  text?: string;
  similarity: number;
  originalEntry?: DatabaseEntry; // Optionally include the full original entry
}

// Helper function to calculate the dot product of two vectors
function dotProduct(vecA: number[], vecB: number[]): number {
  let product = 0;
  for (let i = 0; i < vecA.length; i++) {
    product += vecA[i] * vecB[i];
  }
  return product;
}

// Helper function to calculate the magnitude (length) of a vector
function magnitude(vec: number[]): number {
  let sumOfSquares = 0;
  for (let i = 0; i < vec.length; i++) {
    sumOfSquares += vec[i] * vec[i];
  }
  return Math.sqrt(sumOfSquares);
}

/**
 * Calculates the cosine similarity between two vectors (embeddings).
 * @param vecA The first vector (array of numbers).
 * @param vecB The second vector (array of numbers).
 * @returns The cosine similarity, a value between -1 and 1.
 *          Returns 0 if vectors are of different lengths or if either magnitude is 0.
 */
export function cosineSimilarity(vecA: number[], vecB: number[]): number {
  if (!vecA || !vecB) {
    console.warn("Cosine Similarity: One or both vectors are undefined.");
    return 0;
  }
  if (vecA.length !== vecB.length) {
    console.warn("Cosine Similarity: Vectors must be of the same length.");
    return 0;
  }
  if (vecA.length === 0) {
    // Or handle as an error, or return 1 if both are empty (convention-dependent)
    return vecB.length === 0 ? 1 : 0;
  }

  const magA = magnitude(vecA);
  const magB = magnitude(vecB);

  if (magA === 0 || magB === 0) {
    // If one vector is a zero vector, similarity is 0 (unless both are zero vectors)
    return (magA === 0 && magB === 0) ? 1 : 0;
  }

  const dotProd = dotProduct(vecA, vecB);
  const similarity = dotProd / (magA * magB);
  
  // Clamp similarity to [-1, 1] to handle potential floating point inaccuracies
  return Math.max(-1, Math.min(1, similarity));
}

/**
 * Compares a user-generated embedding with a list of database embeddings
 * and returns a list of entries sorted by similarity.
 *
 * @param userEmbedding The embedding vector generated by the user.
 * @param databaseEntries An array of DatabaseEntry objects.
 *                        The `embedding` property of each DatabaseEntry can be
 *                        a number[] or a JSON string that will be parsed.
 * @returns An array of SimilarityResult objects, sorted by similarity in descending order.
 */
export function findSimilarEntries(
  userEmbedding: number[],
  databaseEntries: DatabaseEntry[]
): SimilarityResult[] {
  if (!userEmbedding || userEmbedding.length === 0) {
    console.warn("findSimilarEntries: User embedding is empty or undefined.");
    return [];
  }
  if (!databaseEntries || databaseEntries.length === 0) {
    console.warn("findSimilarEntries: Database entries list is empty or undefined.");
    return [];
  }

  const results: SimilarityResult[] = databaseEntries.map(entry => {
    let dbEmbeddingVec: number[];

    try {
      if (typeof entry.embedding === 'string') {
        dbEmbeddingVec = JSON.parse(entry.embedding);
      } else if (Array.isArray(entry.embedding)) {
        dbEmbeddingVec = entry.embedding;
      } else {
        console.warn(`Entry with id ${entry.id} has an invalid embedding format. Skipping.`);
        return { id: entry.id, text: entry.text, similarity: -Infinity, originalEntry: entry }; // Use -Infinity to sort errors to bottom
      }

      if (!Array.isArray(dbEmbeddingVec) || dbEmbeddingVec.some(isNaN)) {
        console.warn(`Entry with id ${entry.id} has non-numeric data in embedding after parsing. Skipping.`);
        return { id: entry.id, text: entry.text, similarity: -Infinity, originalEntry: entry };
      }
      
      const similarity = cosineSimilarity(userEmbedding, dbEmbeddingVec);
      return { id: entry.id, text: entry.text, similarity, originalEntry: entry };

    } catch (parseError) {
      console.error(`Error processing embedding for entry id ${entry.id}:`, parseError);
      return { id: entry.id, text: entry.text, similarity: -Infinity, originalEntry: entry };
    }
  });

  // Sort by similarity in descending order
  return results.sort((a, b) => b.similarity - a.similarity);
}

// --- Example Usage (Conceptual - you'd call this from your component) ---
/*
async function getAndCompareEmbeddings(userText: string, db: SQLiteDatabase) {
  // 1. Generate user's embedding (using your useTextEmbedding hook)
  // const { embedding: userEmbedding, error } = await generateEmbedding(userText);
  // if (error || !userEmbedding) {
  //   console.error("Failed to generate user embedding:", error);
  //   return;
  // }

  // 2. Fetch all entries with embeddings from your database
  //    Adjust your SQL query and parsing as needed.
  // const allDbRawEntries = await db.getAllAsync<{ id: number, text: string, embedding_json: string }>('SELECT id, text, embedding_json FROM my_table_with_embeddings;');
  // const databaseEntriesForComparison: DatabaseEntry[] = allDbRawEntries.map(raw => ({
  //   id: raw.id,
  //   text: raw.text,
  //   embedding: raw.embedding_json // The findSimilarEntries function will parse this string
  // }));

  // 3. Find similar entries
  // const similarResults = findSimilarEntries(userEmbedding, databaseEntriesForComparison);

  // 4. Display results
  // console.log("Top similar entries:", similarResults.slice(0, 5));
  // similarResults.forEach(res => {
  //   console.log(`ID: ${res.id}, Text: ${res.text}, Similarity: ${res.similarity.toFixed(4)}`);
  // });
}
*/